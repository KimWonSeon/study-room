# 01.데이터 타입(Data-Type)

## 1 - 1 데이터 타입의 종류

### 자바스크립트의 데이터 타입의 종류

![Alt text](../images/DataTypeImage.jpg)

- **기본형(primitive type)**

  - number (숫자)
  - string (문자열)
  - boolean (불리언)
  - null
  - undefined
  - symbol (심볼) **ES6 +**

- **참조형(reference type)**
  - object (객체)
  - array (배열)
  - function (함수)
  - date (날짜)
  - regExp (정규표현식)
  - map, weakMap, set, weakSet **(ES6 +)**

<br />

### 어떤 기준으로 기본형과 참조형을 구분 하는걸까?

일반적으로 둘 다 모두 복제를 하지만 기본형은 값이 저장된 주소값을 복제하고, 참조형은 프로퍼티들의 주소값 묶음을 가리키는 주소값을 복제한다

**기본형은 불변성(immutability)을 뜁니다**
불변성을 잘 이해하려면 식별자와 변수의 개념을 구분할 수 있어야합니다.

## 1 - 2 변수 선언

변수는 **"변할 수 있는 무언가"** 라고 부르며, "무언가"를 **데이터**라고 말한다.

```js
var a;
```

책에서는 변수를 표현할 때 표를 그리며, 주소와 데이터를 보여주며 데이터 구조 이해라는 목적으로 표현을 한다. **p.5**

따로 변수에 데이터를 할당을 해줄 때에는 별도의 메모리 공간을 확보하여, 주소를 변수영역에 저장하는 식으로 이뤈진다. 데이터의 성질에 따라 "변수 영역", "데이터 영역"으로 구분을 나눈다.

### 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 더 거치는 걸까?

> 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민이라고 한다.

> 내가 생각하기에는 재사용에 영역을 고려한 고민이라 생각한다. 변수라 함은 "변할 수 있는 무언가"이기에 다른 값을 할당받아 저장되는 것이 아닌 데이터값을 재사용하며 효율을 높이는거라 생각한다.

<br />

## 1 - 3 불변값, 가변값

### 불변값

변수와 상수를 구분하는 성질은 "변경 가능성"이다. **바뀔 수 있으며 변수, 바꿀 수 없으면 상수입니다.** 변수와 상수를 구분 짓는 대상은 변수 영역 메모리이며, 한번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지가 관견이다. 반면 불변성 여부는 변경 가능성의 대상인 데이터 영역 메모리이다.

기본형 데이터는 모두 불변값이다.

```js
var a = "abc";
a = a + "def";

var b = 5;
var c = 5;
b = 7;
```

변수 `a`에 문자열 `"abc"`를 할당했다가 뒤에 `"def"`를 추가하면 기존의`"abc"` 공간에 할당하는것이 아닌 `"abcdef"`하는 문자열을 새로 추가하여, 주소를 변수 공간에 연결한다.

변수 `b`는 숫자 5할당이 되어 있고, 값을 7로 바꾸고자 합니다.
5자체를 7로 바꾸는게 아닌, 기존에 저장했던 7을 찾아서 재활용하고, 없으면 새로 만들어 `b`에 저장한다.

> 변경은 새로 만드는 동작을 통해서만 이뤄지며 이것이 불변값 성질이다. 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 변하지 않는다.

<br />

### 가변값

기본형 데이터는 모두 불변값입니다.
참조형 데이터는 기본적인 성질은 가변값이 많지만, 설정에 따라 변경 불가능하 경우와 불변값으로 활용하는 방안이 있다.

```javascript
var obj1 = {
  a: 1,
  b: "bbb",
};
```

기본형과 차이는 객체의 변수(프로퍼티)영역이 별도로 존재합니다.
객체가 별도로 할애한 영역은 변수의 영역일 뿐 데이터 영역은 기존의 메모리 공간을 그대로 활용한다. 데이터 영역의 저장된 값은 불변값이다.
그러나 변수에는 다른 값이 대입이 가능하며, 참조형 데이터는 불변하지 않는다.

<br />

## 1 - 3 - 1 객체 재할당

자바스크립트에서 객체의 프로피티에 다시 객체나 배열 같은 참조형 데이터를 할당하는 경우를 **중첩 객체**라고 합니다. 아래 코드에서 `obj`는 메모리 어딘가에 저장된 배열 `[3, 4, 5]`의 주소값을 프로퍼티 `arr`에 저장하고 있습니다.

```js
var obj = {
  x: 3,
  arr: [3, 4, 5],
};
```

이때 배열 `[3, 4, 5]`는 `obj.arr`에 의해 참조되고 있으므로 참조 카운트는 1이 됩니다.

> **참조 카운트**란 특정 데이터의 주소를 참조하는 변수나 프로퍼티의 개수를 의미하며, 메모리 관리의 핵심 지표가 됩니다.

### 만약 이 상태에서 재할당 명령이 떨어지면 어떻게 되는것 인가?

```js
obj.arr = "str";
```

이 과정에서 `obj.arr`은 기존에 들고 있던 배열 `[3, 4, 5]`의 주소값을 버리고, 새로운 문자열 `"str"`의 주소값을 바라보게 됩니다.<br> 기존에 존재하던 배열 `[3, 4, 5]`를 참조하는 대상이 아무도 없게 되면서 해당 배열의 참조 카운트는 0으로 떨어집니다.

참조 카운트가 0이 된 데이터는 프로그랜 내에서 더 이상 도달할 수 없는 상태가 됩니다. 자바스크립트의 **가비지 컬렉터**는 이렇게 더 이상 사용되지 않는 메모리 공간을 자동으로 찾아 회수합니다.

<br />

## 1 - 3 - 2 변수 복사 비교

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하지만, **데이터 할당 과정**에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생합니다.

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj.c = 20;
```

### 복사 이후 값 변경 시의 동작 차이

위 코드에서 `b = 15`라고 재할당하면 변수 `a`와 `b`는 서로 다른 메모리 주소를 바라보게 됩니다. 반면, `obj2.c = 20`으로 값을 변경하더라도 `obj1`과 `obj2`는 여전히 동일한 객체의 주소를 공유하고 있습니다. 이는 기본형이 **값 자체**를 갈아치우는 방식이라면, 참조형은 **객체 내부의 프로퍼티**만 변경하기 때문입니다.

### 모든 데이터 타입은 결국 참조다

흔히 "기본형은 값을 복사하고 참조형은 주솟값을 복사한다"라고 설명하지만, 엄밀히 말하면 자바스크립트의 모든 데이터 타입은 변수에 할당될 때 주솟값을 복사합니다. 메모리 관점에서 보면 모든 데이터 타입이 참조형의 성격을 띠고 있는 셈입니다.

### 한 단계의 차이가 만드는 결과

결국 차이는 주솟값을 복사하는 단계에서 발생합니다. 기본형 데이터는 주솟값을 복사하는 과정이 단 한 번만 이루어지지만, 참조형 데이터는 객체의 주소를 찾고, 그 안에서 다시 프로퍼티의 주소를 찾아가는 한 단계를 더 거치게 됩니다. 이 **한 단계 더 거치는 구조**가 참조형 데이터의 **가변성**을 만들어내는 핵심 원인이 됩니다.
